# app/database.py

from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from datetime import datetime, timedelta
import asyncio
from .ai_services import get_ai_chat_completion
from datetime import datetime, timedelta, timezone

from . import config
from .ai_services import get_ai_chat_completion # ai_services.pyì—ì„œ í•¨ìˆ˜ import

# SQLAlchemy ì—”ì§„ ë° ì„¸ì…˜ ì„¤ì •
engine = None

def init_db():
    global engine
    try:
        server_engine = create_engine(config.SERVER_DATABASE_URL)
        with server_engine.connect() as connection:
            connection.execute(text(f"CREATE DATABASE IF NOT EXISTS {config.DB_NAME} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci"))
        
        engine = create_engine(config.DATABASE_URL)
        with engine.connect() as connection:
            connection.execute(text("""
            CREATE TABLE IF NOT EXISTS conversations (...);
            """)) # SQL êµ¬ë¬¸ì€ ì´ì „ê³¼ ë™ì¼í•˜ë¯€ë¡œ ê°„ê²°í™”ë¥¼ ìœ„í•´ ìƒëµ
            connection.execute(text("""
            CREATE TABLE IF NOT EXISTS summaries (...);
            """)) # SQL êµ¬ë¬¸ì€ ì´ì „ê³¼ ë™ì¼í•˜ë¯€ë¡œ ê°„ê²°í™”ë¥¼ ìœ„í•´ ìƒëµ
        print("âœ… MySQL ë°ì´í„°ë² ì´ìŠ¤ ë° í…Œì´ë¸”ì´ ì„±ê³µì ìœ¼ë¡œ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.")
        return True
    except Exception as e:
        print(f"âŒ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return False

SessionLocal = None
if init_db():
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
else:
    exit("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨ë¡œ ì„œë²„ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

async def save_conversation_to_mysql(user_id: str, user_message: str, ai_message: str):
    db = SessionLocal()
    try:
        query = text("INSERT INTO conversations (user_id, user_message, ai_message) VALUES (:user_id, :user_message, :ai_message)")
        await asyncio.to_thread(db.execute, query, {"user_id": user_id, "user_message": user_message, "ai_message": ai_message})
        await asyncio.to_thread(db.commit)
    finally:
        db.close()

async def create_hourly_summary_report(user_id: str):
    """
    ë§ˆì§€ë§‰ ë¦¬í¬íŠ¸ ìƒì„± í›„ 1ì‹œê°„ì´ ì§€ë‚¬ê³ , ìƒˆë¡œìš´ ëŒ€í™”ê°€ ìˆì„ ê²½ìš°ì—ë§Œ
    ì‹œê°„ë³„ ìš”ì•½ ë¦¬í¬íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. (UTC ì‹œê°„ ê¸°ì¤€)
    """
    print(f"ğŸ—“ï¸ [{user_id}] ë‹˜ì˜ ì‹œê°„ë³„ ë¦¬í¬íŠ¸ ìƒì„± ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.")
    db = SessionLocal()
    try:
        # 1. ì´ ì‚¬ìš©ìì˜ ê°€ì¥ ìµœê·¼ ë¦¬í¬íŠ¸ ìƒì„± ì‹œê°„ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
        last_summary_query = text("SELECT created_at FROM summaries WHERE user_id = :user_id ORDER BY created_at DESC LIMIT 1")
        last_summary_time = db.execute(last_summary_query, {"user_id": user_id}).scalar_one_or_none()

        # âœ… [ìˆ˜ì •] í˜„ì¬ ì‹œê°„ì„ 'ì‹œê°„ëŒ€ ì •ë³´ê°€ í¬í•¨ëœ' UTC ê¸°ì¤€ìœ¼ë¡œ ëª…í™•í•˜ê²Œ ê°€ì ¸ì˜µë‹ˆë‹¤.
        utc_now = datetime.now(timezone.utc)
        one_hour_ago = utc_now - timedelta(hours=1)

        if last_summary_time:
            # âœ… [ìˆ˜ì •] ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ê°€ì ¸ì˜¨ ì‹œê°„ë„ UTC ê¸°ì¤€ìœ¼ë¡œ ë§Œë“¤ì–´ ë¹„êµí•˜ì—¬ ì‹œê°„ëŒ€ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
            if last_summary_time.tzinfo is None:
                last_summary_time = last_summary_time.replace(tzinfo=timezone.utc)

            if last_summary_time > one_hour_ago:
                print(f"-> ë§ˆì§€ë§‰ ë¦¬í¬íŠ¸ ìƒì„±({last_summary_time.strftime('%H:%M')} UTC) í›„ 1ì‹œê°„ì´ ì§€ë‚˜ì§€ ì•Šì•„, ìƒì„±ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
                return

        # ë§ˆì§€ë§‰ ë¦¬í¬íŠ¸ê°€ ì—†ê±°ë‚˜, 1ì‹œê°„ì´ ì§€ë‚¬ìœ¼ë©´ ì•„ë˜ ë¡œì§ ì‹¤í–‰
        start_time = last_summary_time or datetime.min
        new_conv_query = text("SELECT user_message, ai_message FROM conversations WHERE user_id = :user_id AND created_at > :start_time")
        new_conversations = db.execute(new_conv_query, {"user_id": user_id, "start_time": start_time}).fetchall()

        if not new_conversations:
            print("-> ë¦¬í¬íŠ¸ì— ì¶”ê°€í•  ìƒˆë¡œìš´ ëŒ€í™” ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.")
            return

        print(f"-> ìƒˆë¡œìš´ ëŒ€í™” {len(new_conversations)}ê±´ì„ ë°”íƒ•ìœ¼ë¡œ ì‹œê°„ë³„ ë¦¬í¬íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.")
        conversation_history = "\n".join([f"ì‚¬ìš©ì: {row[0]}\nAI: {row[1]}" for row in new_conversations])
        report_prompt = f"ë‹¤ìŒì€ ì‚¬ìš©ìì˜ ìµœê·¼ ëŒ€í™” ë‚´ìš©ì…ë‹ˆë‹¤. ì´ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì˜ ìƒíƒœì™€ ì£¼ìš” ëŒ€í™” ë‚´ìš©ì„ ìš”ì•½í•˜ëŠ” 'ì‹œê°„ë³„ ë¦¬í¬íŠ¸'ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.\n\n--- ëŒ€í™” ë‚´ìš© ---\n{conversation_history}\n-----------------\n\nì‹œê°„ë³„ ë¦¬í¬íŠ¸:"
        
        report_text = await get_ai_chat_completion(report_prompt)
        
        summary_save_query = text("INSERT INTO summaries (user_id, summary_text) VALUES (:user_id, :summary_text)")
        db.execute(summary_save_query, {"user_id": user_id, "summary_text": report_text})
        db.commit()
        print(f"âœ… [{user_id}] ë‹˜ì˜ ì‹œê°„ë³„ ë¦¬í¬íŠ¸ê°€ MySQL summaries í…Œì´ë¸”ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")

    finally:
        db.close()